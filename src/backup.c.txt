
int heuristic ( int x, int y ) {
	return ( abs ( x - y ) );
}
/*
void a_star ( GRAPHOBJ *graph, int s, int t ) {

	void 	*	tmp;
	Set 	*	AdjList		= NULL;
	Set 	*	closed 		= NULL;
	Heap 	*	open 		= NULL;

	int f[graph->vNum];
	int path[graph->vNum];

	int x, y;
	int cost;
	open = initializeHeap ( minHeapify );
	bool found = false;
	insert ( open, new_HeapData ( s, 0 ) );
	while ( !isHeapEmpty( open ) || !found ) {
		tmp 	= extractFirst ( open );
		x 		= getData ( tmp );
		//dist[x] = getKey ( tmp );
		
		if ( x == t ) {
			found = true;
		}  else {
			AdjList = graph->getAdjList ( graph, x );
			while ( !isEmpty ( AdjList ) ) {
				y = getInt ( getFront ( AdjList ) );
				cost = g ( y ) + heuristic ( y, t );
				//1
				if ( heapIntSearch ( open, y ) && cost < f ( y ) ) {
					updateKey ( open, y, cost );
					path[y] = x;
				} 
				//2
				else if ( intSearch ( closed , y) && cost < f ( y ) ) { 
					deleteFromSet ( closed, y );
					insert ( open, new_HeapData ( y, cost ) );
				}
				// 3
				else if ( !intSearch ( closed , y) && heapIntSearch ( open, y ) ) {
					insert ( open, new_HeapData ( y, cost ) );
				}
				push ( closed , setInt ( x ) );
			}
		}
		if ( found ) {
			path = generate_path ( source, target );
		} else {
			path = NULL;
		}
	}
	return path;
}
*/
/*
void dijkstraHeap ( GRAPHOBJ *graph, int s, int *prev ) {

	Heap 	*		Q 			= NULL;
	Set 	*		AdjList 	= NULL;
	Data 	*		tmp;
	int DEBUG = 0;
	FILE *stream;
	Q = initializeHeap ( minHeapify );
	int i 	= 0;
	int v 	= 0;
	int u 	= 0;
	int alt = 0;
	int colore[graph->vNum];
	int dist[graph->vNum];

	//initializations
	for ( v = 0; v < graph->vNum; v++ ) {
		dist[v] 	= INFINITE;
		prev[v] 	= NIL;
		colore[v] 	= BIANCO;
		if ( s != v )
			insert ( Q, new_HeapData ( v, INFINITE ) );
	}
	dist[s] = 0;
	prev[s] = s;
	insert ( Q, new_HeapData ( s, 0 ) );

	char path[50];
	buildHeap ( Q );
	if ( DEBUG ) {
		sprintf (path, "dijkstra_%c.txt", 'a' + s); 
		stream = openStream ( path, "w+" );	
		fprintf ( stream, "from %c\n\n", 'a' + s );
		Hprint ( Q, stream );
	}

	//main loop
	while ( Q->heapsize > 1 ) {
		//remove and return the best vertex
		
		tmp 	= extractFirst ( Q );
		u 		= getData ( tmp );
		dist[u] = getKey ( tmp );
		colore[u] = NERO;
		AdjList = graph->getAdjList ( graph, u );
		if ( DEBUG ) {
			fprintf ( stream, "nodo estratto: %3d\n", u );
			Hprint ( Q, stream );
			printDist ( graph, stream, dist );
			printAdj ( graph, u, AdjList, stream );
		}
		while ( !isEmpty ( AdjList ) ) {
			v = getInt ( getFront ( AdjList ) );
			if ( colore[v] == BIANCO ) {
				relax ( graph, Q, u, v, dist, prev );
			}
			AdjList = dequeue ( AdjList );
		}
	}
	if ( DEBUG ) {	
		fprintf ( stream, "prev:\n\n" );
		for (u = 0; u < graph->vNum; u++ ) {
			fprintf ( stream, "[%d]->%d ", u, prev[u] );
		}
		fprintf ( stream, "\n" );	
		closeStream ( stream );
	}
}
void relax ( GRAPHOBJ *graph, Heap *Q, int u, int v, int *dist, int *prev) {
	int alt;
	alt = dist[u] + graph->getWeight ( graph, u, v );
	if ( dist[v] > alt ) {
		dist[v] = alt;
		prev[v] = u;
		decreaseKey ( Q, v, alt ) ;
	}
}

void minDPath (int s, int u, GRAPHOBJ *graph ) {

	int  		* 	pred 	= ( int * ) malloc ( graph->vNum * sizeof ( int ) );
	int y = 2;
	int x = 4;


	dijkstraHeap ( graph, s, pred );
	printPath (graph->matrix, s, u, pred, y, x);


	free ( pred );
}

void printDist ( GRAPHOBJ *graph, FILE *stream, int *dist ) {
	fprintf ( stream, "distanze:\n\n");
	int k;
	for ( k = 0; k < graph->vNum; k++ ) {
		fprintf ( stream, " [%d]->%d, ", k, dist[k]);
	}
	fprintf ( stream, "\n\n" );	
}


*/
/**
dato un grafo sotto forma di matrice di adiacenza
restituisce la lista di adiacenza di un nodo, utilizzando una coda.
*/
/*
void printAdj ( GRAPHOBJ *graph, int u, Set *Adj, FILE *stream ) {
	char *s ="-------------------";
	if ( Adj ) {
		fprintf ( stream, "nodo %3d:\n", u );
		fprintf ( stream, "Adiacenze:\n" );
		printSet ( Adj, stream );
		fprintf ( stream, "\n%s%s%s\n", s, s, s );
	} else {
		fprintf ( stream, "nessuna adiacenza\n" );
	}
}

//ATTENZIONE ORDINE GETWEIGHT
Set *getAdjList ( GRAPHOBJ *graph, int u ) {
	Set *res = NULL;
	int weight;
	int i;
	for (i = 0; i < graph->vNum ; i++) {
		weight = graph->getWeight ( graph, u, i );
		if ( weight != 0 && weight != INT_MIN ) {
			res = enqueue (res, setInt ( i ) );
		}
	}
	return res;
}

/**
 * visita breadth_first_search su matrice di adiacenza
*/
 /*
int *breadth_first_search ( GRAPHOBJ *graph, int s ) {

	if ( !check ( graph, "breadth_first_search" ) ) return NULL;
	if ( s >= graph->vNum ) {
		//dialogPanel ( "breadth_first_search: s > dimensione" );
		return NULL;
	}

	int u;
	int v;
	int colore[graph->vNum];
	int *	pred		= ( int *) malloc ( graph->vNum * sizeof ( int ) );
	memset ( pred, 0, graph->vNum );
	Set *	frontier	= NULL;
	Set *	AdjList 	= NULL;

	for ( u = 0; u < graph->vNum; u++ ) {
		colore[u] 	= BIANCO;
		pred[u]		= NIL;
	}
	colore[s] 	= GRIGIO;
	pred[s]		= 0;

	frontier = enqueue ( frontier, setInt ( s ) );

	while ( !isEmpty ( frontier ) ) {
		u = getInt ( getFront ( frontier ) );
		AdjList = graph->getAdjList ( graph, u );

		while ( !isEmpty ( AdjList ) ) {
			v = getInt ( getFront ( AdjList ) );
			AdjList = dequeue ( AdjList );
			if ( colore[v] == BIANCO ) {
				colore[v] = GRIGIO;
				pred[v] = u;
				frontier = enqueue ( frontier, setInt ( v ) );
			}
		}
		frontier = dequeue ( frontier );
		colore[u] = NERO;
	}
	return pred;
}
*/
/**
stampa del cammino minimo
*/
/*
void printPath (GraphT **graph, int s , int v, int *pred,int y, int x ) {

    if (v == s) {
//		mvwprintw ( p->win, y, x, "s: %c", s + 'a' );
    } else if ( pred[v] == NIL ) {
//		mvwprintw ( p->win, y, x, "non esiste cammino tra s e v");
    } else {
		printPath (graph, s, pred[v], pred, y+1, x );
		//mvwprintw ( p->win, y, x, "v: %c ", v + 'a' );
    }
}
/**
cammino minimo
*/
/*
void minPath (int s, int v, GRAPHOBJ *graph ) {

	int 		*	pred 	= NULL;
	int y = 2;
	int x = 4;

	pred = breadth_first_search ( graph, s );
	//printPath (graph->matrix, s, v, pred, y, x);


	free ( pred );
}
*/